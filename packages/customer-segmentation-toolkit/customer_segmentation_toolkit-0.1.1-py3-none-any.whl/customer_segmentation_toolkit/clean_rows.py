# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/02_clean_rows.ipynb (unless otherwise specified).

__all__ = ['clean_drop_na', 'clean_drop_duplicates', 'clean_remove_bad_order_cancellations', 'clean_data_rows']

# Cell
import logging
import pandas as pd

# Cell

def clean_drop_na(df: pd.DataFrame) -> pd.DataFrame:
    df = df.dropna(axis=0, subset=['CustomerID'])
    return df

def clean_drop_duplicates(df: pd.DataFrame) -> pd.DataFrame:
    df = df.drop_duplicates()
    return df

# Cell

def clean_remove_bad_order_cancellations(df: pd.DataFrame) -> pd.DataFrame:
    """
    Returns a copy of `df` that doesn't include the following orders:
      1. a cancel order exists without counterpart,
      2. a order for which there exists at least one counterpart with exactly the same quantity.
    NOTE: time complexity is O(n).
    """

    df_cleaned = df.copy(deep=True)
    df_cleaned['QuantityCanceled'] = 0

    entry_to_remove = [] ; doubtfull_entry = []

    for index, col in  df.iterrows():
        if col['Quantity'] > 0 or col['Description'] == 'Discount':
            continue
        df_test = df[(df['CustomerID'] == col['CustomerID']) &
                     (df['StockCode']  == col['StockCode']) &
                     (df['InvoiceDate'] < col['InvoiceDate']) &
                     (df['Quantity']   > 0)].copy()

        # Cancelation WITHOUT counterpart
        if df_test.shape[0] == 0:
            doubtfull_entry.append(index)

        # Cancelation WITH a counterpart
        elif df_test.shape[0] == 1:
            index_order = df_test.index[0]
            df_cleaned.loc[index_order, 'QuantityCanceled'] = -col['Quantity']
            entry_to_remove.append(index)

        # Various counterparts exist in orders: we delete the last one
        elif df_test.shape[0] > 1:
            df_test.sort_index(axis=0 ,ascending=False, inplace=True)
            for ind, val in df_test.iterrows():
                if val['Quantity'] < -col['Quantity']: continue
                df_cleaned.loc[ind, 'QuantityCanceled'] = -col['Quantity']
                entry_to_remove.append(index)
                break

    #logging.info("entry_to_remove: {}".format(len(entry_to_remove)))
    #logging.info("doubtfull_entry: {}".format(len(doubtfull_entry)))

    df_cleaned.drop(entry_to_remove, axis=0, inplace=True)
    df_cleaned.drop(doubtfull_entry, axis=0, inplace=True)

    remaining_entries = df_cleaned[(df_cleaned['Quantity'] < 0) & (df_cleaned['StockCode'] != 'D')]
    #logging.info("nb of entries to delete: {}".format(remaining_entries.shape[0]))
    #logging.info(str(remaining_entries[:5]))

    df_cleaned['TotalPrice'] = df_cleaned['UnitPrice'] * (df_cleaned['Quantity'] - df_cleaned['QuantityCanceled'])

    return df_cleaned

# Cell

def clean_data_rows(df: pd.DataFrame) -> pd.DataFrame:
    df = clean_drop_na(df)
    df = clean_drop_duplicates(df)
    df = clean_remove_bad_order_cancellations(df)
    return df