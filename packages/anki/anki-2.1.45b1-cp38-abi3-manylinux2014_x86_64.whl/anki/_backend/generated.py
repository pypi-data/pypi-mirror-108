# Copyright: Ankitects Pty Ltd and contributors
# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html
# pylint: skip-file

from __future__ import annotations

"""
THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT.

Please do not access methods on the backend directly - they may be changed
or removed at any time. Instead, please use the methods on the collection
instead. Eg, don't use col.backend.all_deck_config(), instead use
col.decks.all_config()
"""
    
from typing import *

import anki._backend.backend_pb2 as pb

class RustBackendGenerated:
    def _run_command(self, service: int, method: int, input: Any) -> bytes:
        raise Exception("not implemented")
    
    def sched_timing_today(self) -> pb.SchedTimingTodayOut:
        input = pb.Empty()
        output = pb.SchedTimingTodayOut()
        output.ParseFromString(self._run_command(0, 0, input))
        return output

    def studied_today(self) -> str:
        input = pb.Empty()
        output = pb.String()
        output.ParseFromString(self._run_command(0, 1, input))
        return output.val

    def studied_today_message(self, *, cards: int, seconds: float) -> str:
        input = pb.StudiedTodayMessageIn(cards=cards, seconds=seconds)
        output = pb.String()
        output.ParseFromString(self._run_command(0, 2, input))
        return output.val

    def update_stats(self, *, deck_id: int, new_delta: int, review_delta: int, millisecond_delta: int) -> pb.Empty:
        input = pb.UpdateStatsIn(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta, millisecond_delta=millisecond_delta)
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 3, input))
        return output

    def extend_limits(self, *, deck_id: int, new_delta: int, review_delta: int) -> pb.Empty:
        input = pb.ExtendLimitsIn(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta)
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 4, input))
        return output

    def counts_for_deck_today(self, did: int) -> pb.CountsForDeckTodayOut:
        input = pb.DeckId(did=did)
        output = pb.CountsForDeckTodayOut()
        output.ParseFromString(self._run_command(0, 5, input))
        return output

    def congrats_info(self) -> pb.CongratsInfoOut:
        input = pb.Empty()
        output = pb.CongratsInfoOut()
        output.ParseFromString(self._run_command(0, 6, input))
        return output

    def restore_buried_and_suspended_cards(self, cids: Sequence[int]) -> pb.OpChanges:
        input = pb.CardIds(cids=cids)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 7, input))
        return output

    def unbury_deck(self, *, deck_id: int, mode: pb.UnburyDeckIn.Mode.V) -> pb.OpChanges:
        input = pb.UnburyDeckIn(deck_id=deck_id, mode=mode)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 8, input))
        return output

    def bury_or_suspend_cards(self, *, card_ids: Sequence[int], note_ids: Sequence[int], mode: pb.BuryOrSuspendCardsIn.Mode.V) -> pb.OpChangesWithCount:
        input = pb.BuryOrSuspendCardsIn(card_ids=card_ids, note_ids=note_ids, mode=mode)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 9, input))
        return output

    def empty_filtered_deck(self, did: int) -> pb.OpChanges:
        input = pb.DeckId(did=did)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 10, input))
        return output

    def rebuild_filtered_deck(self, did: int) -> pb.OpChangesWithCount:
        input = pb.DeckId(did=did)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 11, input))
        return output

    def schedule_cards_as_new(self, *, card_ids: Sequence[int], log: bool) -> pb.OpChanges:
        input = pb.ScheduleCardsAsNewIn(card_ids=card_ids, log=log)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 12, input))
        return output

    def set_due_date(self, *, card_ids: Sequence[int], days: str, config_key: pb.Config.String) -> pb.OpChanges:
        input = pb.SetDueDateIn(card_ids=card_ids, days=days, config_key=config_key)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 13, input))
        return output

    def sort_cards(self, *, card_ids: Sequence[int], starting_from: int, step_size: int, randomize: bool, shift_existing: bool) -> pb.OpChangesWithCount:
        input = pb.SortCardsIn(card_ids=card_ids, starting_from=starting_from, step_size=step_size, randomize=randomize, shift_existing=shift_existing)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 14, input))
        return output

    def sort_deck(self, *, deck_id: int, randomize: bool) -> pb.OpChangesWithCount:
        input = pb.SortDeckIn(deck_id=deck_id, randomize=randomize)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 15, input))
        return output

    def get_next_card_states(self, cid: int) -> pb.NextCardStates:
        input = pb.CardId(cid=cid)
        output = pb.NextCardStates()
        output.ParseFromString(self._run_command(0, 16, input))
        return output

    def describe_next_states(self, input: pb.NextCardStates) -> Sequence[str]:
        output = pb.StringList()
        output.ParseFromString(self._run_command(0, 17, input))
        return output.vals

    def state_is_leech(self, input: pb.SchedulingState) -> bool:
        output = pb.Bool()
        output.ParseFromString(self._run_command(0, 18, input))
        return output.val

    def answer_card(self, input: pb.CardAnswer) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 19, input))
        return output

    def upgrade_scheduler(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 20, input))
        return output

    def get_queued_cards(self, *, fetch_limit: int, intraday_learning_only: bool) -> pb.QueuedCards:
        input = pb.GetQueuedCardsIn(fetch_limit=fetch_limit, intraday_learning_only=intraday_learning_only)
        output = pb.QueuedCards()
        output.ParseFromString(self._run_command(0, 21, input))
        return output

    def add_deck_legacy(self, json: bytes) -> pb.OpChangesWithId:
        input = pb.Json(json=json)
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 0, input))
        return output

    def add_or_update_deck_legacy(self, *, deck: bytes, preserve_usn_and_mtime: bool) -> int:
        input = pb.AddOrUpdateDeckLegacyIn(deck=deck, preserve_usn_and_mtime=preserve_usn_and_mtime)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(1, 1, input))
        return output.did

    def deck_tree(self, *, now: int, top_deck_id: int) -> pb.DeckTreeNode:
        input = pb.DeckTreeIn(now=now, top_deck_id=top_deck_id)
        output = pb.DeckTreeNode()
        output.ParseFromString(self._run_command(1, 2, input))
        return output

    def deck_tree_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 3, input))
        return output.json

    def get_all_decks_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 4, input))
        return output.json

    def get_deck_id_by_name(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(1, 5, input))
        return output.did

    def get_deck(self, did: int) -> pb.Deck:
        input = pb.DeckId(did=did)
        output = pb.Deck()
        output.ParseFromString(self._run_command(1, 6, input))
        return output

    def update_deck(self, input: pb.Deck) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 7, input))
        return output

    def update_deck_legacy(self, json: bytes) -> pb.OpChanges:
        input = pb.Json(json=json)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 8, input))
        return output

    def set_deck_collapsed(self, *, deck_id: int, collapsed: bool, scope: pb.SetDeckCollapsedIn.Scope.V) -> pb.OpChanges:
        input = pb.SetDeckCollapsedIn(deck_id=deck_id, collapsed=collapsed, scope=scope)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 9, input))
        return output

    def get_deck_legacy(self, did: int) -> bytes:
        input = pb.DeckId(did=did)
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 10, input))
        return output.json

    def get_deck_names(self, *, skip_empty_default: bool, include_filtered: bool) -> Sequence[pb.DeckNameId]:
        input = pb.GetDeckNamesIn(skip_empty_default=skip_empty_default, include_filtered=include_filtered)
        output = pb.DeckNames()
        output.ParseFromString(self._run_command(1, 11, input))
        return output.entries

    def new_deck_legacy(self, val: bool) -> bytes:
        input = pb.Bool(val=val)
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 12, input))
        return output.json

    def remove_decks(self, dids: Sequence[int]) -> pb.OpChangesWithCount:
        input = pb.DeckIds(dids=dids)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 13, input))
        return output

    def reparent_decks(self, *, deck_ids: Sequence[int], new_parent: int) -> pb.OpChangesWithCount:
        input = pb.ReparentDecksIn(deck_ids=deck_ids, new_parent=new_parent)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 14, input))
        return output

    def rename_deck(self, *, deck_id: int, new_name: str) -> pb.OpChanges:
        input = pb.RenameDeckIn(deck_id=deck_id, new_name=new_name)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 15, input))
        return output

    def get_or_create_filtered_deck(self, did: int) -> pb.FilteredDeckForUpdate:
        input = pb.DeckId(did=did)
        output = pb.FilteredDeckForUpdate()
        output.ParseFromString(self._run_command(1, 16, input))
        return output

    def add_or_update_filtered_deck(self, input: pb.FilteredDeckForUpdate) -> pb.OpChangesWithId:
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 17, input))
        return output

    def filtered_deck_order_labels(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.StringList()
        output.ParseFromString(self._run_command(1, 18, input))
        return output.vals

    def set_current_deck(self, did: int) -> pb.OpChanges:
        input = pb.DeckId(did=did)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 19, input))
        return output

    def get_current_deck(self) -> pb.Deck:
        input = pb.Empty()
        output = pb.Deck()
        output.ParseFromString(self._run_command(1, 20, input))
        return output

    def new_note(self, ntid: int) -> pb.Note:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Note()
        output.ParseFromString(self._run_command(2, 0, input))
        return output

    def add_note(self, *, note: pb.Note, deck_id: int) -> pb.AddNoteOut:
        input = pb.AddNoteIn(note=note, deck_id=deck_id)
        output = pb.AddNoteOut()
        output.ParseFromString(self._run_command(2, 1, input))
        return output

    def defaults_for_adding(self, home_deck_of_current_review_card: int) -> pb.DeckAndNotetype:
        input = pb.DefaultsForAddingIn(home_deck_of_current_review_card=home_deck_of_current_review_card)
        output = pb.DeckAndNotetype()
        output.ParseFromString(self._run_command(2, 2, input))
        return output

    def default_deck_for_notetype(self, ntid: int) -> int:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(2, 3, input))
        return output.did

    def update_note(self, *, note: pb.Note, skip_undo_entry: bool) -> pb.OpChanges:
        input = pb.UpdateNoteIn(note=note, skip_undo_entry=skip_undo_entry)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(2, 4, input))
        return output

    def get_note(self, nid: int) -> pb.Note:
        input = pb.NoteId(nid=nid)
        output = pb.Note()
        output.ParseFromString(self._run_command(2, 5, input))
        return output

    def remove_notes(self, *, note_ids: Sequence[int], card_ids: Sequence[int]) -> pb.OpChangesWithCount:
        input = pb.RemoveNotesIn(note_ids=note_ids, card_ids=card_ids)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 6, input))
        return output

    def cloze_numbers_in_note(self, input: pb.Note) -> Sequence[int]:
        output = pb.ClozeNumbersInNoteOut()
        output.ParseFromString(self._run_command(2, 7, input))
        return output.numbers

    def after_note_updates(self, *, nids: Sequence[int], mark_notes_modified: bool, generate_cards: bool) -> pb.OpChangesWithCount:
        input = pb.AfterNoteUpdatesIn(nids=nids, mark_notes_modified=mark_notes_modified, generate_cards=generate_cards)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 8, input))
        return output

    def field_names_for_notes(self, nids: Sequence[int]) -> Sequence[str]:
        input = pb.FieldNamesForNotesIn(nids=nids)
        output = pb.FieldNamesForNotesOut()
        output.ParseFromString(self._run_command(2, 9, input))
        return output.fields

    def note_is_duplicate_or_empty(self, input: pb.Note) -> pb.NoteIsDuplicateOrEmptyOut:
        output = pb.NoteIsDuplicateOrEmptyOut()
        output.ParseFromString(self._run_command(2, 10, input))
        return output

    def cards_of_note(self, nid: int) -> Sequence[int]:
        input = pb.NoteId(nid=nid)
        output = pb.CardIds()
        output.ParseFromString(self._run_command(2, 11, input))
        return output.cids

    def sync_media(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 0, input))
        return output

    def abort_sync(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 1, input))
        return output

    def abort_media_sync(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 2, input))
        return output

    def before_upload(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 3, input))
        return output

    def sync_login(self, *, username: str, password: str) -> pb.SyncAuth:
        input = pb.SyncLoginIn(username=username, password=password)
        output = pb.SyncAuth()
        output.ParseFromString(self._run_command(3, 4, input))
        return output

    def sync_status(self, input: pb.SyncAuth) -> pb.SyncStatusOut:
        output = pb.SyncStatusOut()
        output.ParseFromString(self._run_command(3, 5, input))
        return output

    def sync_collection(self, input: pb.SyncAuth) -> pb.SyncCollectionOut:
        output = pb.SyncCollectionOut()
        output.ParseFromString(self._run_command(3, 6, input))
        return output

    def full_upload(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 7, input))
        return output

    def full_download(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 8, input))
        return output

    def sync_server_method(self, *, method: pb.SyncServerMethodIn.Method.V, data: bytes) -> bytes:
        input = pb.SyncServerMethodIn(method=method, data=data)
        output = pb.Json()
        output.ParseFromString(self._run_command(3, 9, input))
        return output.json

    def add_notetype(self, input: pb.Notetype) -> pb.OpChangesWithId:
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 0, input))
        return output

    def update_notetype(self, input: pb.Notetype) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 1, input))
        return output

    def add_notetype_legacy(self, json: bytes) -> pb.OpChangesWithId:
        input = pb.Json(json=json)
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 2, input))
        return output

    def update_notetype_legacy(self, json: bytes) -> pb.OpChanges:
        input = pb.Json(json=json)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 3, input))
        return output

    def add_or_update_notetype(self, *, json: bytes, preserve_usn_and_mtime: bool) -> int:
        input = pb.AddOrUpdateNotetypeIn(json=json, preserve_usn_and_mtime=preserve_usn_and_mtime)
        output = pb.NotetypeId()
        output.ParseFromString(self._run_command(4, 4, input))
        return output.ntid

    def get_stock_notetype_legacy(self, kind: pb.StockNotetype.Kind.V) -> bytes:
        input = pb.StockNotetype(kind=kind)
        output = pb.Json()
        output.ParseFromString(self._run_command(4, 5, input))
        return output.json

    def get_notetype(self, ntid: int) -> pb.Notetype:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Notetype()
        output.ParseFromString(self._run_command(4, 6, input))
        return output

    def get_notetype_legacy(self, ntid: int) -> bytes:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Json()
        output.ParseFromString(self._run_command(4, 7, input))
        return output.json

    def get_notetype_names(self) -> Sequence[pb.NotetypeNameId]:
        input = pb.Empty()
        output = pb.NotetypeNames()
        output.ParseFromString(self._run_command(4, 8, input))
        return output.entries

    def get_notetype_names_and_counts(self) -> Sequence[pb.NotetypeNameIdUseCount]:
        input = pb.Empty()
        output = pb.NotetypeUseCounts()
        output.ParseFromString(self._run_command(4, 9, input))
        return output.entries

    def get_notetype_id_by_name(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.NotetypeId()
        output.ParseFromString(self._run_command(4, 10, input))
        return output.ntid

    def remove_notetype(self, ntid: int) -> pb.OpChanges:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 11, input))
        return output

    def get_aux_notetype_config_key(self, *, id: int, key: str) -> str:
        input = pb.GetAuxConfigKeyIn(id=id, key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(4, 12, input))
        return output.val

    def get_aux_template_config_key(self, *, notetype_id: int, card_ordinal: int, key: str) -> str:
        input = pb.GetAuxTemplateConfigKeyIn(notetype_id=notetype_id, card_ordinal=card_ordinal, key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(4, 13, input))
        return output.val

    def get_config_json(self, val: str) -> bytes:
        input = pb.String(val=val)
        output = pb.Json()
        output.ParseFromString(self._run_command(5, 0, input))
        return output.json

    def set_config_json(self, *, key: str, value_json: bytes, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigJsonIn(key=key, value_json=value_json, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 1, input))
        return output

    def set_config_json_no_undo(self, *, key: str, value_json: bytes, undoable: bool) -> pb.Empty:
        input = pb.SetConfigJsonIn(key=key, value_json=value_json, undoable=undoable)
        output = pb.Empty()
        output.ParseFromString(self._run_command(5, 2, input))
        return output

    def remove_config(self, val: str) -> pb.OpChanges:
        input = pb.String(val=val)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 3, input))
        return output

    def get_all_config(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(5, 4, input))
        return output.json

    def get_config_bool(self, key: pb.Config.Bool.Key.V) -> bool:
        input = pb.Config.Bool(key=key)
        output = pb.Bool()
        output.ParseFromString(self._run_command(5, 5, input))
        return output.val

    def set_config_bool(self, *, key: pb.Config.Bool.Key.V, value: bool, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigBoolIn(key=key, value=value, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 6, input))
        return output

    def get_config_string(self, key: pb.Config.String.Key.V) -> str:
        input = pb.Config.String(key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(5, 7, input))
        return output.val

    def set_config_string(self, *, key: pb.Config.String.Key.V, value: str, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigStringIn(key=key, value=value, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 8, input))
        return output

    def get_preferences(self) -> pb.Preferences:
        input = pb.Empty()
        output = pb.Preferences()
        output.ParseFromString(self._run_command(5, 9, input))
        return output

    def set_preferences(self, input: pb.Preferences) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 10, input))
        return output

    def extract_av_tags(self, *, text: str, question_side: bool) -> pb.ExtractAVTagsOut:
        input = pb.ExtractAVTagsIn(text=text, question_side=question_side)
        output = pb.ExtractAVTagsOut()
        output.ParseFromString(self._run_command(6, 0, input))
        return output

    def extract_latex(self, *, text: str, svg: bool, expand_clozes: bool) -> pb.ExtractLatexOut:
        input = pb.ExtractLatexIn(text=text, svg=svg, expand_clozes=expand_clozes)
        output = pb.ExtractLatexOut()
        output.ParseFromString(self._run_command(6, 1, input))
        return output

    def get_empty_cards(self) -> pb.EmptyCardsReport:
        input = pb.Empty()
        output = pb.EmptyCardsReport()
        output.ParseFromString(self._run_command(6, 2, input))
        return output

    def render_existing_card(self, *, card_id: int, browser: bool) -> pb.RenderCardOut:
        input = pb.RenderExistingCardIn(card_id=card_id, browser=browser)
        output = pb.RenderCardOut()
        output.ParseFromString(self._run_command(6, 3, input))
        return output

    def render_uncommitted_card(self, *, note: pb.Note, card_ord: int, template: pb.Notetype.Template, fill_empty: bool) -> pb.RenderCardOut:
        input = pb.RenderUncommittedCardIn(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = pb.RenderCardOut()
        output.ParseFromString(self._run_command(6, 4, input))
        return output

    def render_uncommitted_card_legacy(self, *, note: pb.Note, card_ord: int, template: bytes, fill_empty: bool) -> pb.RenderCardOut:
        input = pb.RenderUncommittedCardLegacyIn(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = pb.RenderCardOut()
        output.ParseFromString(self._run_command(6, 5, input))
        return output

    def strip_av_tags(self, val: str) -> str:
        input = pb.String(val=val)
        output = pb.String()
        output.ParseFromString(self._run_command(6, 6, input))
        return output.val

    def render_markdown(self, *, markdown: str, sanitize: bool) -> str:
        input = pb.RenderMarkdownIn(markdown=markdown, sanitize=sanitize)
        output = pb.String()
        output.ParseFromString(self._run_command(6, 7, input))
        return output.val

    def add_or_update_deck_config_legacy(self, json: bytes) -> int:
        input = pb.Json(json=json)
        output = pb.DeckConfigId()
        output.ParseFromString(self._run_command(7, 0, input))
        return output.dcid

    def get_deck_config(self, dcid: int) -> pb.DeckConfig:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.DeckConfig()
        output.ParseFromString(self._run_command(7, 1, input))
        return output

    def all_deck_config_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 2, input))
        return output.json

    def get_deck_config_legacy(self, dcid: int) -> bytes:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 3, input))
        return output.json

    def new_deck_config_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 4, input))
        return output.json

    def remove_deck_config(self, dcid: int) -> pb.Empty:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.Empty()
        output.ParseFromString(self._run_command(7, 5, input))
        return output

    def get_deck_configs_for_update(self, did: int) -> pb.DeckConfigsForUpdate:
        input = pb.DeckId(did=did)
        output = pb.DeckConfigsForUpdate()
        output.ParseFromString(self._run_command(7, 6, input))
        return output

    def update_deck_configs(self, input: pb.UpdateDeckConfigsIn) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(7, 7, input))
        return output

    def clear_unused_tags(self) -> pb.OpChangesWithCount:
        input = pb.Empty()
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 0, input))
        return output

    def all_tags(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.StringList()
        output.ParseFromString(self._run_command(8, 1, input))
        return output.vals

    def remove_tags(self, val: str) -> pb.OpChangesWithCount:
        input = pb.String(val=val)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 2, input))
        return output

    def set_tag_collapsed(self, *, name: str, collapsed: bool) -> pb.OpChanges:
        input = pb.SetTagCollapsedIn(name=name, collapsed=collapsed)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(8, 3, input))
        return output

    def tag_tree(self) -> pb.TagTreeNode:
        input = pb.Empty()
        output = pb.TagTreeNode()
        output.ParseFromString(self._run_command(8, 4, input))
        return output

    def reparent_tags(self, *, tags: Sequence[str], new_parent: str) -> pb.OpChangesWithCount:
        input = pb.ReparentTagsIn(tags=tags, new_parent=new_parent)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 5, input))
        return output

    def rename_tags(self, *, current_prefix: str, new_prefix: str) -> pb.OpChangesWithCount:
        input = pb.RenameTagsIn(current_prefix=current_prefix, new_prefix=new_prefix)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 6, input))
        return output

    def add_note_tags(self, *, note_ids: Sequence[int], tags: str) -> pb.OpChangesWithCount:
        input = pb.NoteIdsAndTagsIn(note_ids=note_ids, tags=tags)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 7, input))
        return output

    def remove_note_tags(self, *, note_ids: Sequence[int], tags: str) -> pb.OpChangesWithCount:
        input = pb.NoteIdsAndTagsIn(note_ids=note_ids, tags=tags)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 8, input))
        return output

    def find_and_replace_tag(self, *, note_ids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool) -> pb.OpChangesWithCount:
        input = pb.FindAndReplaceTagIn(note_ids=note_ids, search=search, replacement=replacement, regex=regex, match_case=match_case)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 9, input))
        return output

    def build_search_string(self, input: pb.SearchNode) -> str:
        output = pb.String()
        output.ParseFromString(self._run_command(9, 0, input))
        return output.val

    def search_cards(self, *, search: str, order: pb.SortOrder) -> Sequence[int]:
        input = pb.SearchIn(search=search, order=order)
        output = pb.SearchOut()
        output.ParseFromString(self._run_command(9, 1, input))
        return output.ids

    def search_notes(self, *, search: str, order: pb.SortOrder) -> Sequence[int]:
        input = pb.SearchIn(search=search, order=order)
        output = pb.SearchOut()
        output.ParseFromString(self._run_command(9, 2, input))
        return output.ids

    def join_search_nodes(self, *, joiner: pb.SearchNode.Group.Joiner.V, existing_node: pb.SearchNode, additional_node: pb.SearchNode) -> str:
        input = pb.JoinSearchNodesIn(joiner=joiner, existing_node=existing_node, additional_node=additional_node)
        output = pb.String()
        output.ParseFromString(self._run_command(9, 3, input))
        return output.val

    def replace_search_node(self, *, existing_node: pb.SearchNode, replacement_node: pb.SearchNode) -> str:
        input = pb.ReplaceSearchNodeIn(existing_node=existing_node, replacement_node=replacement_node)
        output = pb.String()
        output.ParseFromString(self._run_command(9, 4, input))
        return output.val

    def find_and_replace(self, *, nids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool, field_name: str) -> pb.OpChangesWithCount:
        input = pb.FindAndReplaceIn(nids=nids, search=search, replacement=replacement, regex=regex, match_case=match_case, field_name=field_name)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(9, 5, input))
        return output

    def all_browser_columns(self) -> Sequence[pb.BrowserColumns.Column]:
        input = pb.Empty()
        output = pb.BrowserColumns()
        output.ParseFromString(self._run_command(9, 6, input))
        return output.columns

    def browser_row_for_id(self, val: int) -> pb.BrowserRow:
        input = pb.Int64(val=val)
        output = pb.BrowserRow()
        output.ParseFromString(self._run_command(9, 7, input))
        return output

    def set_active_browser_columns(self, vals: Sequence[str]) -> pb.Empty:
        input = pb.StringList(vals=vals)
        output = pb.Empty()
        output.ParseFromString(self._run_command(9, 8, input))
        return output

    def card_stats(self, cid: int) -> str:
        input = pb.CardId(cid=cid)
        output = pb.String()
        output.ParseFromString(self._run_command(10, 0, input))
        return output.val

    def graphs(self, *, search: str, days: int) -> bytes:
        input = pb.GraphsIn(search=search, days=days)
        return self._run_command(10, 1, input)

    def get_graph_preferences(self) -> bytes:
        input = pb.Empty()
        return self._run_command(10, 2, input)

    def set_graph_preferences(self, input: pb.GraphPreferences) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(10, 3, input))
        return output

    def check_media(self) -> pb.CheckMediaOut:
        input = pb.Empty()
        output = pb.CheckMediaOut()
        output.ParseFromString(self._run_command(11, 0, input))
        return output

    def trash_media_files(self, fnames: Sequence[str]) -> pb.Empty:
        input = pb.TrashMediaFilesIn(fnames=fnames)
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 1, input))
        return output

    def add_media_file(self, *, desired_name: str, data: bytes) -> str:
        input = pb.AddMediaFileIn(desired_name=desired_name, data=data)
        output = pb.String()
        output.ParseFromString(self._run_command(11, 2, input))
        return output.val

    def empty_trash(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 3, input))
        return output

    def restore_trash(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 4, input))
        return output

    def translate_string(self, input: pb.TranslateStringIn) -> str:
        output = pb.String()
        output.ParseFromString(self._run_command(12, 0, input))
        return output.val

    def format_timespan(self, *, seconds: float, context: pb.FormatTimespanIn.Context.V) -> str:
        input = pb.FormatTimespanIn(seconds=seconds, context=context)
        output = pb.String()
        output.ParseFromString(self._run_command(12, 1, input))
        return output.val

    def i18n_resources(self, modules: Sequence[str]) -> bytes:
        input = pb.I18nResourcesIn(modules=modules)
        output = pb.Json()
        output.ParseFromString(self._run_command(12, 2, input))
        return output.json

    def open_collection(self, *, collection_path: str, media_folder_path: str, media_db_path: str, log_path: str) -> pb.Empty:
        input = pb.OpenCollectionIn(collection_path=collection_path, media_folder_path=media_folder_path, media_db_path=media_db_path, log_path=log_path)
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 0, input))
        return output

    def close_collection(self, downgrade_to_schema11: bool) -> pb.Empty:
        input = pb.CloseCollectionIn(downgrade_to_schema11=downgrade_to_schema11)
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 1, input))
        return output

    def check_database(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.CheckDatabaseOut()
        output.ParseFromString(self._run_command(13, 2, input))
        return output.problems

    def get_undo_status(self) -> pb.UndoStatus:
        input = pb.Empty()
        output = pb.UndoStatus()
        output.ParseFromString(self._run_command(13, 3, input))
        return output

    def undo(self) -> pb.OpChangesAfterUndo:
        input = pb.Empty()
        output = pb.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 4, input))
        return output

    def redo(self) -> pb.OpChangesAfterUndo:
        input = pb.Empty()
        output = pb.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 5, input))
        return output

    def add_custom_undo_entry(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.UInt32()
        output.ParseFromString(self._run_command(13, 6, input))
        return output.val

    def merge_undo_entries(self, val: int) -> pb.OpChanges:
        input = pb.UInt32(val=val)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(13, 7, input))
        return output

    def latest_progress(self) -> pb.Progress:
        input = pb.Empty()
        output = pb.Progress()
        output.ParseFromString(self._run_command(13, 8, input))
        return output

    def set_wants_abort(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 9, input))
        return output

    def get_card(self, cid: int) -> pb.Card:
        input = pb.CardId(cid=cid)
        output = pb.Card()
        output.ParseFromString(self._run_command(14, 0, input))
        return output

    def update_card(self, *, card: pb.Card, skip_undo_entry: bool) -> pb.OpChanges:
        input = pb.UpdateCardIn(card=card, skip_undo_entry=skip_undo_entry)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(14, 1, input))
        return output

    def remove_cards(self, card_ids: Sequence[int]) -> pb.Empty:
        input = pb.RemoveCardsIn(card_ids=card_ids)
        output = pb.Empty()
        output.ParseFromString(self._run_command(14, 2, input))
        return output

    def set_deck(self, *, card_ids: Sequence[int], deck_id: int) -> pb.OpChangesWithCount:
        input = pb.SetDeckIn(card_ids=card_ids, deck_id=deck_id)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 3, input))
        return output

    def set_flag(self, *, card_ids: Sequence[int], flag: int) -> pb.OpChangesWithCount:
        input = pb.SetFlagIn(card_ids=card_ids, flag=flag)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 4, input))
        return output
